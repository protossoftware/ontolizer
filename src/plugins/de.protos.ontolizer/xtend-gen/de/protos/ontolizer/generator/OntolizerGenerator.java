/**
 * generated by Xtext 2.9.2
 */
package de.protos.ontolizer.generator;

import de.protos.ontolizer.ontolizer.Edge;
import de.protos.ontolizer.ontolizer.EdgeList;
import de.protos.ontolizer.ontolizer.EdgeType;
import de.protos.ontolizer.ontolizer.Model;
import de.protos.ontolizer.ontolizer.Node;
import de.protos.ontolizer.ontolizer.NodeType;
import de.protos.ontolizer.ontolizer.View;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class OntolizerGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    this.generateViewFiles(resource, fsa);
    this.generateAntBuildfile(fsa);
  }
  
  public CharSequence generateDotFileContent(final Model model, final View view) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("digraph {");
    _builder.newLine();
    {
      EList<Node> _nodes = model.getNodes();
      EList<NodeType> _nodeTypes = view.getNodeTypes();
      Iterable<Node> _filterNodesForNodeTypes = this.filterNodesForNodeTypes(_nodes, _nodeTypes);
      for(final Node node : _filterNodesForNodeTypes) {
        _builder.append("\t\t");
        String _name = node.getName();
        _builder.append(_name, "\t\t");
        _builder.append(" [");
        String _xifexpression = null;
        EList<String> _summary = node.getSummary();
        boolean _isNullOrEmpty = IterableExtensions.isNullOrEmpty(_summary);
        if (_isNullOrEmpty) {
          _xifexpression = "";
        } else {
          String _name_1 = node.getName();
          String _plus = ("label=\"" + _name_1);
          String _plus_1 = (_plus + "\\n");
          EList<String> _summary_1 = node.getSummary();
          String _plus_2 = (_plus_1 + _summary_1);
          _xifexpression = (_plus_2 + "\" ");
        }
        _builder.append(_xifexpression, "\t\t");
        String _nodeFormatString = this.getNodeFormatString(node);
        _builder.append(_nodeFormatString, "\t\t");
        _builder.append("];\t\t\t\t");
        _builder.newLineIfNotEmpty();
        {
          EList<EdgeList> _edgeLists = node.getEdgeLists();
          EList<EdgeType> _edgeTypes = view.getEdgeTypes();
          Iterable<EdgeList> _filterEdgeListsForEdgeTypes = this.filterEdgeListsForEdgeTypes(_edgeLists, _edgeTypes);
          for(final EdgeList edgeList : _filterEdgeListsForEdgeTypes) {
            {
              EList<Edge> _edges = edgeList.getEdges();
              EList<NodeType> _nodeTypes_1 = view.getNodeTypes();
              Iterable<Edge> _filterEdgesForNodeTypes = this.filterEdgesForNodeTypes(_edges, _nodeTypes_1);
              for(final Edge edge : _filterEdgesForNodeTypes) {
                _builder.append("\t\t");
                String _name_2 = node.getName();
                _builder.append(_name_2, "\t\t");
                _builder.append(" -> ");
                Node _targetNode = edge.getTargetNode();
                String _name_3 = _targetNode.getName();
                _builder.append(_name_3, "\t\t");
                _builder.append(" [ label = \"");
                EdgeType _edgeType = edgeList.getEdgeType();
                String _name_4 = _edgeType.getName();
                _builder.append(_name_4, "\t\t");
                _builder.append("\" ];");
                _builder.newLineIfNotEmpty();
              }
            }
          }
        }
      }
    }
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public String getNodeFormatString(final Node node) {
    String _xblockexpression = null;
    {
      final ArrayList<String> formatList = CollectionLiterals.<String>newArrayList();
      NodeType _nodeType = node.getNodeType();
      String _shape = _nodeType.getShape();
      boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_shape);
      boolean _not = (!_isNullOrEmpty);
      if (_not) {
        NodeType _nodeType_1 = node.getNodeType();
        String _shape_1 = _nodeType_1.getShape();
        String _plus = ("shape=" + _shape_1);
        formatList.add(_plus);
      }
      NodeType _nodeType_2 = node.getNodeType();
      String _color = _nodeType_2.getColor();
      boolean _isNullOrEmpty_1 = StringExtensions.isNullOrEmpty(_color);
      boolean _not_1 = (!_isNullOrEmpty_1);
      if (_not_1) {
        NodeType _nodeType_3 = node.getNodeType();
        String _color_1 = _nodeType_3.getColor();
        String _plus_1 = ("fillcolor=" + _color_1);
        formatList.add(_plus_1);
      }
      NodeType _nodeType_4 = node.getNodeType();
      String _style = _nodeType_4.getStyle();
      boolean _isNullOrEmpty_2 = StringExtensions.isNullOrEmpty(_style);
      boolean _not_2 = (!_isNullOrEmpty_2);
      if (_not_2) {
        NodeType _nodeType_5 = node.getNodeType();
        String _style_1 = _nodeType_5.getStyle();
        String _plus_2 = ("style=" + _style_1);
        formatList.add(_plus_2);
      }
      final Function1<String, Boolean> _function = (String s) -> {
        boolean _isEmpty = s.isEmpty();
        return Boolean.valueOf((!_isEmpty));
      };
      Iterable<String> _filter = IterableExtensions.<String>filter(formatList, _function);
      _xblockexpression = IterableExtensions.join(_filter, ",");
    }
    return _xblockexpression;
  }
  
  private void generateAntBuildfile(final IFileSystemAccess2 fsa) {
    CharSequence _generateDotBuildfileContent = this.generateDotBuildfileContent();
    fsa.generateFile("build.xml", _generateDotBuildfileContent);
  }
  
  private CharSequence generateDotBuildfileContent() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    _builder.newLine();
    _builder.append("<!-- ====================================================================== ");
    _builder.newLine();
    _builder.append("     ");
    _builder.append("Generates bitmap images from DOT files for process documentation");
    _builder.newLine();
    _builder.append("     ");
    _builder.append("====================================================================== -->");
    _builder.newLine();
    _builder.append("<project name=\"builddotfiles\" default=\"build\">");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("<description>");
    _builder.newLine();
    _builder.append("\t   \t");
    _builder.append("Generates bitmap images from DOT files for process documentation");
    _builder.newLine();
    _builder.append("\t   ");
    _builder.append("</description>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("<target name=\"build\" description=\"description\" depends=\"init-dot.binpath\">");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("<apply executable=\"${dot.binpath}\" dest=\"./\">");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<arg value=\"-Tjpg\" />");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<srcfile />");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<arg value=\"-o\" />");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<targetfile />");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<fileset dir=\"./\" includes=\"*.dot\" />");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<mapper type=\"glob\" from=\"*.dot\" to=\"*.jpg\" />");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("</apply>");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("</target>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("<target name=\"init-dot.binpath\" unless=\"dot.binpath\">");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("<property environment=\"env\" />");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("<condition property=\"dot.binpath\" value=\"${env.DOT_PATH}/dot\" else=\"dot\">");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("<isset property=\"env.DOT_PATH\" />");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("</condition>");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("</target>");
    _builder.newLine();
    _builder.newLine();
    _builder.append("</project>");
    _builder.newLine();
    return _builder;
  }
  
  public boolean generateViewFiles(final Resource resource, final IFileSystemAccess2 fsa) {
    boolean _xblockexpression = false;
    {
      EList<EObject> _contents = resource.getContents();
      EObject _head = IterableExtensions.<EObject>head(_contents);
      final Model model = ((Model) _head);
      EList<View> _views = model.getViews();
      final Function1<View, Boolean> _function = (View e) -> {
        boolean _xblockexpression_1 = false;
        {
          String _name = e.getName();
          String _plus = ("View_" + _name);
          String _plus_1 = (_plus + ".dot");
          CharSequence _generateViewFileContent = this.generateViewFileContent(model, e);
          fsa.generateFile(_plus_1, _generateViewFileContent);
          _xblockexpression_1 = true;
        }
        return Boolean.valueOf(_xblockexpression_1);
      };
      _xblockexpression = IterableExtensions.<View>forall(_views, _function);
    }
    return _xblockexpression;
  }
  
  public Iterable<Node> filterNodesForNodeTypes(final EList<Node> nodes, final EList<NodeType> nodeTypes) {
    Iterable<Node> _xifexpression = null;
    boolean _isEmpty = nodeTypes.isEmpty();
    if (_isEmpty) {
      _xifexpression = nodes;
    } else {
      final Function1<Node, Boolean> _function = (Node e) -> {
        NodeType _nodeType = e.getNodeType();
        return Boolean.valueOf(nodeTypes.contains(_nodeType));
      };
      _xifexpression = IterableExtensions.<Node>filter(nodes, _function);
    }
    return _xifexpression;
  }
  
  public Iterable<EdgeList> filterEdgeListsForEdgeTypes(final Iterable<EdgeList> edgeLists, final EList<EdgeType> edgeTypes) {
    Iterable<EdgeList> _xifexpression = null;
    boolean _isEmpty = edgeTypes.isEmpty();
    if (_isEmpty) {
      _xifexpression = edgeLists;
    } else {
      final Function1<EdgeList, Boolean> _function = (EdgeList e) -> {
        EdgeType _edgeType = e.getEdgeType();
        return Boolean.valueOf(edgeTypes.contains(_edgeType));
      };
      _xifexpression = IterableExtensions.<EdgeList>filter(edgeLists, _function);
    }
    return _xifexpression;
  }
  
  public Iterable<Edge> filterEdgesForNodeTypes(final Iterable<Edge> edges, final EList<NodeType> nodeTypes) {
    Iterable<Edge> _xifexpression = null;
    boolean _isEmpty = nodeTypes.isEmpty();
    if (_isEmpty) {
      _xifexpression = edges;
    } else {
      final Function1<Edge, Boolean> _function = (Edge e) -> {
        Node _targetNode = e.getTargetNode();
        NodeType _nodeType = _targetNode.getNodeType();
        return Boolean.valueOf(nodeTypes.contains(_nodeType));
      };
      _xifexpression = IterableExtensions.<Edge>filter(edges, _function);
    }
    return _xifexpression;
  }
  
  public CharSequence generateViewFileContent(final Model model, final View view) {
    return this.generateDotFileContent(model, view);
  }
}
